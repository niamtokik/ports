$OpenBSD: patch-daemon_gdm-local-display-factory_c,v 1.20 2021/06/18 12:00:53 robert Exp $

Index: daemon/gdm-local-display-factory.c
--- daemon/gdm-local-display-factory.c.orig
+++ daemon/gdm-local-display-factory.c
@@ -28,7 +28,9 @@
 #include <glib-object.h>
 #include <gio/gio.h>
 
+#if 0
 #include <systemd/sd-login.h>
+#endif
 
 #include "gdm-common.h"
 #include "gdm-manager.h"
@@ -42,6 +44,7 @@
 #include "gdm-local-display.h"
 #include "gdm-legacy-display.h"
 
+#define CK_SEAT1_PATH                       "/org/freedesktop/ConsoleKit/Seat1"
 #define GDM_DBUS_PATH                       "/org/gnome/DisplayManager"
 #define GDM_LOCAL_DISPLAY_FACTORY_DBUS_PATH GDM_DBUS_PATH "/LocalDisplayFactory"
 #define GDM_MANAGER_DBUS_NAME               "org.gnome.DisplayManager.LocalDisplayFactory"
@@ -61,8 +64,10 @@ struct _GdmLocalDisplayFactory
         /* FIXME: this needs to be per seat? */
         guint            num_failures;
 
+#if 0
         guint            seat_new_id;
         guint            seat_removed_id;
+#endif
         guint            seat_properties_changed_id;
 
         gboolean         seat0_graphics_check_timed_out;
@@ -90,11 +95,15 @@ static void     on_display_status_changed             
                                                          GParamSpec                  *arg1,
                                                          GdmLocalDisplayFactory      *factory);
 
+#if 0
 static gboolean gdm_local_display_factory_sync_seats    (GdmLocalDisplayFactory *factory);
+#endif
 static gpointer local_display_factory_object = NULL;
+#if 0
 static gboolean lookup_by_session_id (const char *id,
                                       GdmDisplay *display,
                                       gpointer    user_data);
+#endif
 
 G_DEFINE_TYPE (GdmLocalDisplayFactory, gdm_local_display_factory, GDM_TYPE_DISPLAY_FACTORY)
 
@@ -235,7 +244,7 @@ gdm_local_display_factory_create_transient_display (Gd
 
         g_debug ("GdmLocalDisplayFactory: Creating transient display");
 
-#ifdef ENABLE_USER_DISPLAY_SERVER
+#if defined ENABLE_USER_DISPLAY_SERVER && defined WITH_SYSTEMD
         display = gdm_local_display_new ();
         if (gdm_local_display_factory_use_wayland ())
                 g_object_set (G_OBJECT (display), "session-type", "wayland", NULL);
@@ -276,6 +285,7 @@ gdm_local_display_factory_create_transient_display (Gd
         return ret;
 }
 
+#if 0
 static void
 finish_display_on_seat_if_waiting (GdmDisplayStore *display_store,
                                    GdmDisplay      *display,
@@ -330,6 +340,7 @@ on_session_registered_cb (GObject *gobject,
 
         finish_waiting_displays_on_seat (factory, "seat0");
 }
+#endif
 
 static void
 on_display_status_changed (GdmDisplay             *display,
@@ -376,7 +387,7 @@ on_display_status_changed (GdmDisplay             *dis
                         /* reset num failures */
                         factory->num_failures = 0;
 
-                        gdm_local_display_factory_sync_seats (factory);
+                        ensure_display_for_seat (factory, seat_id);
                 }
                 break;
         case GDM_DISPLAY_FAILED:
@@ -480,9 +491,11 @@ ensure_display_for_seat (GdmLocalDisplayFactory *facto
         const char *session_type = "wayland";
         GdmDisplayStore *store;
         GdmDisplay      *display = NULL;
+#if 0
         g_autofree char *login_session_id = NULL;
+#endif
 
-        ret = sd_seat_can_graphical (seat_id);
+        ret = 1;
 
         if (ret < 0) {
                 g_critical ("Failed to query CanGraphical information for seat %s", seat_id);
@@ -497,7 +510,7 @@ ensure_display_for_seat (GdmLocalDisplayFactory *facto
                 seat_supports_graphics = TRUE;
         }
 
-        if (g_strcmp0 (seat_id, "seat0") == 0) {
+        if (g_strcmp0 (seat_id, CK_SEAT1_PATH) == 0) {
                 is_seat0 = TRUE;
 
                 /* If we've failed, or are explicitly told to, fall back to legacy X11 support
@@ -576,6 +589,7 @@ ensure_display_for_seat (GdmLocalDisplayFactory *facto
                 return;
         }
 
+#if 0
         /* If we already have a login window, switch to it */
         if (gdm_get_login_window_session_id (seat_id, &login_session_id)) {
                 GdmDisplay *display;
@@ -593,6 +607,7 @@ ensure_display_for_seat (GdmLocalDisplayFactory *facto
                         return;
                 }
         }
+#endif
 
         g_debug ("GdmLocalDisplayFactory: Adding display on seat %s", seat_id);
 
@@ -628,6 +643,7 @@ ensure_display_for_seat (GdmLocalDisplayFactory *facto
         return;
 }
 
+#if 0
 static void
 delete_display (GdmLocalDisplayFactory *factory,
                 const char             *seat_id) {
@@ -790,6 +806,7 @@ lookup_by_tty (const char *id,
 
         return g_strcmp0 (tty_to_check, tty_to_find) == 0;
 }
+#endif
 
 #if defined(ENABLE_USER_DISPLAY_SERVER)
 static void
@@ -967,6 +984,7 @@ on_vt_changed (GIOChannel    *source,
 }
 #endif
 
+#if 0
 static void
 gdm_local_display_factory_start_monitor (GdmLocalDisplayFactory *factory)
 {
@@ -1016,10 +1034,12 @@ gdm_local_display_factory_start_monitor (GdmLocalDispl
         }
 #endif
 }
+#endif
 
 static void
 gdm_local_display_factory_stop_monitor (GdmLocalDisplayFactory *factory)
 {
+#if 0
         if (factory->seat_new_id) {
                 g_dbus_connection_signal_unsubscribe (factory->connection,
                                                       factory->seat_new_id);
@@ -1045,6 +1065,7 @@ gdm_local_display_factory_stop_monitor (GdmLocalDispla
                 factory->wait_to_finish_timeout_id = 0;
         }
 #endif
+#endif
 }
 
 static void
@@ -1097,8 +1118,13 @@ gdm_local_display_factory_start (GdmDisplayFactory *ba
                                  factory,
                                  0);
 
+#if 0
         gdm_local_display_factory_start_monitor (factory);
         return gdm_local_display_factory_sync_seats (factory);
+#else
+        ensure_display_for_seat (factory, CK_SEAT1_PATH);
+        return TRUE;
+#endif
 }
 
 static gboolean
