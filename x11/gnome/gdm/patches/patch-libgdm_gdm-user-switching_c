$OpenBSD: patch-libgdm_gdm-user-switching_c,v 1.6 2021/05/29 14:02:24 ajacoutot Exp $

Index: libgdm/gdm-user-switching.c
--- libgdm/gdm-user-switching.c.orig
+++ libgdm/gdm-user-switching.c
@@ -31,7 +31,9 @@
 #include <glib-object.h>
 #include <gio/gio.h>
 
+#if 0
 #include <systemd/sd-login.h>
+#endif
 
 #include "common/gdm-common.h"
 #include "gdm-user-switching.h"
@@ -68,6 +70,84 @@ create_transient_display (GDBusConnection *connection,
 }
 
 static gboolean
+get_current_session_id (GDBusConnection  *connection,
+                        char            **session_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "GetCurrentSession",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", session_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static gboolean
+get_seat_id_for_session (GDBusConnection  *connection,
+                         const char       *session_id,
+                         char            **seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSeatId",
+                                             NULL, /* parameters */
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine seat: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
+
+        g_variant_get (reply, "(o)", seat_id);
+        g_variant_unref (reply);
+
+        return TRUE;
+}
+
+static char *
+get_current_seat_id (GDBusConnection *connection)
+{
+        gboolean res;
+        char    *session_id;
+        char    *seat_id;
+
+        session_id = NULL;
+        seat_id = NULL;
+
+        res = get_current_session_id (connection, &session_id);
+        if (res) {
+                res = get_seat_id_for_session (connection, session_id, &seat_id);
+        }
+        g_free (session_id);
+
+        return seat_id;
+}
+
+static gboolean
 activate_session_id (GDBusConnection  *connection,
                      GCancellable     *cancellable,
                      const char       *seat_id,
@@ -77,15 +157,15 @@ activate_session_id (GDBusConnection  *connection,
         GVariant *reply;
 
         reply = g_dbus_connection_call_sync (connection,
-                                             "org.freedesktop.login1",
-                                             "/org/freedesktop/login1",
-                                             "org.freedesktop.login1.Manager",
-                                             "ActivateSessionOnSeat",
-                                             g_variant_new ("(ss)", session_id, seat_id),
+                                             "org.freedesktop.ConsoleKit",
+                                             seat_id,
+                                             "org.freedesktop.ConsoleKit.Seat",
+                                             "ActivateSession",
+                                             g_variant_new ("(o)", session_id),
                                              NULL,
                                              G_DBUS_CALL_FLAGS_NONE,
                                              -1,
-                                             cancellable, error);
+                                             NULL, error);
         if (reply == NULL) {
                 g_prefix_error (error, _("Unable to activate session: "));
                 return FALSE;
@@ -97,88 +177,137 @@ activate_session_id (GDBusConnection  *connection,
 }
 
 static gboolean
-get_login_window_session_id (const char  *seat_id,
-                             char       **session_id)
+session_is_login_window (GDBusConnection *connection,
+                         const char      *session_id)
 {
-        gboolean   ret;
-        int        res, i;
-        char     **sessions;
-        char      *service_id;
-        char      *service_class;
-        char      *state;
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char *value;
+        gboolean ret;
 
-        res = sd_seat_get_sessions (seat_id, &sessions, NULL, NULL);
-        if (res < 0) {
-                g_debug ("Failed to determine sessions: %s", strerror (-res));
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine session type: %s", local_error->message);
+                g_error_free (local_error);
                 return FALSE;
         }
 
-        if (sessions == NULL || sessions[0] == NULL) {
-                *session_id = NULL;
+        g_variant_get (reply, "(&s)", &value);
+
+        if (value == NULL || value[0] == '\0' || strcmp (value, "LoginWindow") != 0) {
+                ret = FALSE;
+        } else {
                 ret = TRUE;
-                goto out;
         }
 
-        for (i = 0; sessions[i]; i ++) {
+        g_variant_unref (reply);
 
-                res = sd_session_get_class (sessions[i], &service_class);
-                if (res < 0) {
-                        g_debug ("failed to determine class of session %s: %s", sessions[i], strerror (-res));
-                        ret = FALSE;
-                        goto out;
-                }
+        return ret;
+}
 
-                if (strcmp (service_class, "greeter") != 0) {
-                        free (service_class);
-                        continue;
-                }
+static gboolean
+seat_can_activate_sessions (GDBusConnection *connection,
+                            const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        gboolean ret;
 
-                free (service_class);
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             seat_id,
+                                             "org.freedesktop.ConsoleKit.Seat",
+                                             "CanActivateSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to determine if can activate sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
 
-                ret = sd_session_get_state (sessions[i], &state);
-                if (ret < 0) {
-                        g_debug ("failed to determine state of session %s: %s", sessions[i], strerror (-res));
-                        ret = FALSE;
-                        goto out;
-                }
+        g_variant_get (reply, "(b)", &ret);
+        g_variant_unref (reply);
 
-                if (g_strcmp0 (state, "closing") == 0) {
-                        free (state);
-                        continue;
-                }
-                free (state);
+        return ret;
+}
 
-                res = sd_session_get_service (sessions[i], &service_id);
-                if (res < 0) {
-                        g_debug ("failed to determine service of session %s: %s", sessions[i], strerror (-res));
-                        ret = FALSE;
-                        goto out;
-                }
+static const char **
+seat_get_sessions (GDBusConnection *connection,
+                   const char      *seat_id)
+{
+        GError *local_error = NULL;
+        GVariant *reply;
+        const char **value;
 
-                if (strcmp (service_id, "gdm-launch-environment") == 0) {
-                        *session_id = g_strdup (sessions[i]);
-                        ret = TRUE;
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             seat_id,
+                                             "org.freedesktop.ConsoleKit.Seat",
+                                             "GetSessions",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(ao)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, &local_error);
+        if (reply == NULL) {
+                g_warning ("Unable to list sessions: %s", local_error->message);
+                g_error_free (local_error);
+                return FALSE;
+        }
 
-                        free (service_id);
-                        goto out;
-                }
+        g_variant_get (reply, "(^ao)", &value);
+        g_variant_unref (reply);
 
-                free (service_id);
-        }
+        return value;
+}
 
+static gboolean
+get_login_window_session_id (GDBusConnection  *connection,
+                             const char       *seat_id,
+                             char            **session_id)
+{
+        gboolean     can_activate_sessions;
+        const char **sessions;
+        int          i;
+
         *session_id = NULL;
-        ret = TRUE;
+        sessions = NULL;
 
-out:
-        if (sessions) {
-                for (i = 0; sessions[i]; i ++) {
-                        free (sessions[i]);
-                }
+        g_debug ("checking if seat can activate sessions");
 
-                free (sessions);
+        can_activate_sessions = seat_can_activate_sessions (connection, seat_id);
+        if (! can_activate_sessions) {
+                g_debug ("seat is unable to activate sessions");
+                return FALSE;
         }
 
-        return ret;
+        sessions = seat_get_sessions (connection, seat_id);
+        for (i = 0; sessions [i] != NULL; i++) {
+                const char *ssid;
+
+                ssid = sessions [i];
+
+                if (session_is_login_window (connection, ssid)) {
+                        *session_id = g_strdup (ssid);
+                        break;
+                }
+        }
+        g_free (sessions);
+
+        return TRUE;
 }
 
 static gboolean
@@ -187,55 +316,42 @@ goto_login_session (GDBusConnection  *connection,
                     GError          **error)
 {
         gboolean        ret;
-        int             res;
-        char           *our_session;
+        gboolean        res;
         char           *session_id;
         char           *seat_id;
-        GError         *local_error = NULL;
 
         ret = FALSE;
-        session_id = NULL;
-        seat_id = NULL;
 
         /* First look for any existing LoginWindow sessions on the seat.
            If none are found, create a new one. */
 
-        /* Note that we mostly use free () here, instead of g_free ()
-         * since the data allocated is from libsystemd-logind, which
-         * does not use GLib's g_malloc (). */
-        if (!gdm_find_display_session (0, getuid (), &our_session, &local_error)) {
-                g_propagate_prefixed_error (error, local_error, _("Could not identify the current session: "));
+        seat_id = get_current_seat_id (connection);
+        if (seat_id == NULL || seat_id[0] == '\0') {
+                g_debug ("seat id is not set; can't switch sessions");
+                g_set_error (error, GDM_CLIENT_ERROR, 0, _("Could not identify the current session."));
 
                 return FALSE;
         }
 
-        res = sd_session_get_seat (our_session, &seat_id);
-        free (our_session);
-        if (res < 0) {
-                g_debug ("failed to determine own seat: %s", strerror (-res));
-                g_set_error (error, GDM_CLIENT_ERROR, 0, _("Could not identify the current seat."));
-
+        res = get_login_window_session_id (connection, seat_id, &session_id);
+        if (! res) {
+                g_set_error (error, GDM_CLIENT_ERROR, 0, _("User unable to switch sessions."));
                 return FALSE;
         }
 
-        res = get_login_window_session_id (seat_id, &session_id);
-        if (res && session_id != NULL) {
+        if (session_id != NULL) {
                 res = activate_session_id (connection, cancellable, seat_id, session_id, error);
-
                 if (res) {
                         ret = TRUE;
                 }
         }
 
-        if (! ret && g_strcmp0 (seat_id, "seat0") == 0) {
+        if (! ret && g_strcmp0 (seat_id, "/org/freedesktop/ConsoleKit/Seat1") == 0) {
                 res = create_transient_display (connection, cancellable, error);
                 if (res) {
                         ret = TRUE;
                 }
         }
-
-        free (seat_id);
-        g_free (session_id);
 
         return ret;
 }
