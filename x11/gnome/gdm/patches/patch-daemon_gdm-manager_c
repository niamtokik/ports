$OpenBSD: patch-daemon_gdm-manager_c,v 1.28 2021/05/29 14:02:24 ajacoutot Exp $

Index: daemon/gdm-manager.c
--- daemon/gdm-manager.c.orig
+++ daemon/gdm-manager.c
@@ -36,7 +36,9 @@
 
 #include <act/act-user-manager.h>
 
+#if 0
 #include <systemd/sd-login.h>
+#endif
 
 #include "gdm-common.h"
 
@@ -61,7 +63,7 @@
 #define GDM_MANAGER_PATH          GDM_DBUS_PATH "/Manager"
 #define GDM_MANAGER_DISPLAYS_PATH GDM_DBUS_PATH "/Displays"
 
-#define INITIAL_SETUP_USERNAME "gnome-initial-setup"
+#define INITIAL_SETUP_USERNAME "_gnome-initial-setup"
 #define ALREADY_RAN_INITIAL_SETUP_ON_THIS_BOOT GDM_RUN_DIR "/gdm.ran-initial-setup"
 
 typedef struct
@@ -206,51 +208,62 @@ plymouth_quit_without_transition (void)
 #endif
 
 static char *
-get_session_id_for_pid (pid_t    pid,
-                        GError **error)
+get_session_id_for_pid (GDBusConnection  *connection,
+                        pid_t             pid,
+                        GError          **error)
 {
-        char *session, *gsession;
-        int ret;
+        GVariant *reply;
+        char *retval;
 
-        session = NULL;
-        ret = sd_pid_get_session (pid, &session);
-        if (ret < 0) {
-                g_set_error (error,
-                             GDM_DISPLAY_ERROR,
-                             GDM_DISPLAY_ERROR_GETTING_SESSION_INFO,
-                             "Error getting session id from systemd: %s",
-                             g_strerror (-ret));
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             "/org/freedesktop/ConsoleKit/Manager",
+                                             "org.freedesktop.ConsoleKit.Manager",
+                                             "GetSessionForUnixProcess",
+                                             g_variant_new ("(u)", pid),
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL, error);
+        if (reply == NULL) {
                 return NULL;
         }
 
-        if (session != NULL) {
-                gsession = g_strdup (session);
-                free (session);
+        g_variant_get (reply, "(o)", &retval);
+        g_variant_unref (reply);
 
-                return gsession;
-        } else {
-                return NULL;
-        }
+        return retval;
 }
 
 static gboolean
-get_uid_for_session_id (const char  *session_id,
-                        uid_t       *uid,
-                        GError     **error)
+get_uid_for_session_id (GDBusConnection  *connection,
+                        const char       *session_id,
+                        uid_t            *out_uid,
+                        GError          **error)
 {
-        int ret;
+        GVariant *reply;
+        guint32 uid;
 
-        ret = sd_session_get_uid (session_id, uid);
-        if (ret < 0) {
-                g_set_error (error,
-                             GDM_DISPLAY_ERROR,
-                             GDM_DISPLAY_ERROR_GETTING_SESSION_INFO,
-                             "Error getting uid for session id %s from systemd: %s",
-                             session_id,
-                             g_strerror (-ret));
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetUnixUser",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(u)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
                 return FALSE;
         }
 
+        g_variant_get (reply, "(u)", &uid);
+        g_variant_unref (reply);
+
+        *out_uid = (uid_t) uid;
+
         return TRUE;
 }
 
@@ -267,31 +280,39 @@ lookup_by_session_id (const char *id,
 }
 
 static gboolean
-is_login_session (GdmManager  *self,
-                  const char  *session_id,
-                  GError     **error)
+is_login_session (GdmManager       *self,
+                  GDBusConnection  *connection,
+                  const char       *session_id,
+                  GError          **error)
 {
-        char *session_class = NULL;
-        int ret;
+        GVariant *reply;
+        char *session_type = NULL;
 
-        ret = sd_session_get_class (session_id, &session_class);
-
-        if (ret < 0) {
-                g_set_error (error,
-                             GDM_DISPLAY_ERROR,
-                             GDM_DISPLAY_ERROR_GETTING_SESSION_INFO,
-                             "Error getting class for session id %s from systemd: %s",
-                             session_id,
-                             g_strerror (-ret));
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSessionType",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(s)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
                 return FALSE;
         }
 
-        if (g_strcmp0 (session_class, "greeter") != 0) {
-                g_free (session_class);
+        g_variant_get (reply, "(s)", &session_type);
+        g_variant_unref (reply);
+
+        if (g_strcmp0 (session_type, "LoginWindow") != 0) {
+                g_free (session_type);
+
                 return FALSE;
         }
 
-        g_free (session_class);
+        g_free (session_type);
         return TRUE;
 }
 
@@ -302,21 +323,19 @@ session_unlock (GdmManager *manager,
         GError *error = NULL;
         GVariant *reply;
 
-        g_debug ("Unlocking session %s", ssid);
-
         reply = g_dbus_connection_call_sync (manager->priv->connection,
-                                             "org.freedesktop.login1",
-                                             "/org/freedesktop/login1",
-                                             "org.freedesktop.login1.Manager",
-                                             "UnlockSession",
-                                             g_variant_new ("(s)", ssid),
+                                             "org.freedesktop.ConsoleKit",
+                                             ssid,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "Unlock",
+                                             NULL, /* parameters */
                                              NULL, /* expected reply */
                                              G_DBUS_CALL_FLAGS_NONE,
                                              -1,
                                              NULL,
                                              &error);
         if (reply == NULL) {
-                g_debug ("GdmManager: logind 'UnlockSession' %s raised:\n %s\n\n",
+                g_debug ("GdmManager: ConsoleKit %s raised:\n %s\n\n",
                          g_dbus_error_get_remote_error (error), error->message);
                 g_error_free (error);
                 return FALSE;
@@ -375,88 +394,69 @@ find_session_for_user_on_seat (GdmManager *manager,
 }
 
 static gboolean
-is_remote_session (GdmManager  *self,
-                   const char  *session_id,
-                   GError     **error)
+is_remote_session (GdmManager       *self,
+                   GDBusConnection  *connection,
+                   const char       *session_id,
+                   GError          **error)
 {
-        char *seat;
-        int ret;
+        GVariant *reply;
         gboolean is_remote;
 
-        /* FIXME: The next release of logind is going to have explicit api for
-         * checking remoteness.
-         */
-        seat = NULL;
-        ret = sd_session_get_seat (session_id, &seat);
-
-        if (ret < 0 && ret != -ENXIO) {
-                g_debug ("GdmManager: Error while retrieving seat for session %s: %s",
-                         session_id, strerror (-ret));
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "IsLocal",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(b)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return FALSE;
         }
 
-        if (seat != NULL) {
-                is_remote = FALSE;
-                free (seat);
-        } else {
-                is_remote = TRUE;
-        }
+        g_variant_get (reply, "(b)", &is_remote);
+        g_variant_unref (reply);
 
         return is_remote;
 }
 
 static char *
-get_seat_id_for_session_id (const char  *session_id,
-                            GError     **error)
+get_seat_id_for_session_id (GDBusConnection  *connection,
+                            const char       *session_id,
+                            GError          **error)
 {
-        int ret;
-        char *seat, *out_seat;
+        GVariant *reply;
+        char *retval;
 
-        seat = NULL;
-        ret = sd_session_get_seat (session_id, &seat);
-
-        if (ret == -ENXIO) {
-                out_seat = NULL;
-        } else if (ret < 0) {
-                g_set_error (error,
-                             GDM_DISPLAY_ERROR,
-                             GDM_DISPLAY_ERROR_GETTING_SESSION_INFO,
-                             "Error getting uid for session id %s from systemd: %s",
-                             session_id,
-                             g_strerror (-ret));
-                out_seat = NULL;
-        } else {
-                out_seat = g_strdup (seat);
-                free (seat);
+        reply = g_dbus_connection_call_sync (connection,
+                                             "org.freedesktop.ConsoleKit",
+                                             session_id,
+                                             "org.freedesktop.ConsoleKit.Session",
+                                             "GetSeatId",
+                                             NULL,
+                                             G_VARIANT_TYPE ("(o)"),
+                                             G_DBUS_CALL_FLAGS_NONE,
+                                             -1,
+                                             NULL,
+                                             error);
+        if (reply == NULL) {
+                return NULL;
         }
 
-        return out_seat;
+        g_variant_get (reply, "(o)", &retval);
+        g_variant_unref (reply);
+
+        return retval;
 }
 
 static char *
 get_tty_for_session_id (const char  *session_id,
                         GError     **error)
 {
-        int ret;
-        char *tty, *out_tty;
-
-        ret = sd_session_get_tty (session_id, &tty);
-
-        if (ret == -ENXIO) {
-                out_tty = NULL;
-        } else if (ret < 0) {
-                g_set_error (error,
-                             GDM_DISPLAY_ERROR,
-                             GDM_DISPLAY_ERROR_GETTING_SESSION_INFO,
-                             "Error getting tty for session id %s from systemd: %s",
-                             session_id,
-                             g_strerror (-ret));
-                out_tty = NULL;
-        } else {
-                out_tty = g_strdup (tty);
-                free (tty);
-        }
-
-        return out_tty;
+        return NULL;
 }
 
 static void
@@ -501,11 +501,10 @@ get_display_and_details_for_bus_sender (GdmManager    
                 goto out;
         }
 
-        ret = gdm_find_display_session (pid, caller_uid, &session_id, &error);
+        session_id = get_session_id_for_pid (connection, pid, &error);
 
-        if (!ret) {
-                g_debug ("GdmManager: Unable to find display session for uid %d: %s",
-                         (int) caller_uid,
+        if (session_id == NULL) {
+                g_debug ("GdmManager: Error while retrieving session id for sender: %s",
                          error->message);
                 g_error_free (error);
                 goto out;
@@ -516,7 +515,7 @@ get_display_and_details_for_bus_sender (GdmManager    
         }
 
         if (out_is_login_screen != NULL) {
-                *out_is_login_screen = is_login_session (self, session_id, &error);
+                *out_is_login_screen = is_login_session (self, connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while checking if sender is login screen: %s",
@@ -526,7 +525,7 @@ get_display_and_details_for_bus_sender (GdmManager    
                 }
         }
 
-        if (!get_uid_for_session_id (session_id, &session_uid, &error)) {
+        if (!get_uid_for_session_id (connection, session_id, &session_uid, &error)) {
                 g_debug ("GdmManager: Error while retrieving uid for session: %s",
                          error->message);
                 g_error_free (error);
@@ -543,7 +542,7 @@ get_display_and_details_for_bus_sender (GdmManager    
         }
 
         if (out_seat_id != NULL) {
-                *out_seat_id = get_seat_id_for_session_id (session_id, &error);
+                *out_seat_id = get_seat_id_for_session_id (connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while retrieving seat id for session: %s",
@@ -553,7 +552,7 @@ get_display_and_details_for_bus_sender (GdmManager    
         }
 
         if (out_is_remote != NULL) {
-                *out_is_remote = is_remote_session (self, session_id, &error);
+                *out_is_remote = is_remote_session (self, connection, session_id, &error);
 
                 if (error != NULL) {
                         g_debug ("GdmManager: Error while retrieving remoteness for session: %s",
@@ -981,7 +980,8 @@ on_reauthentication_client_rejected (GdmSession       
                  * same audit session, ignore it since it doesn't "own" the
                  * reauthentication session
                  */
-                client_session_id = get_session_id_for_pid (pid_of_client,
+                client_session_id = get_session_id_for_pid (self->priv->connection,
+                                                            pid_of_client,
                                                             NULL);
                 session_id = g_object_get_data (G_OBJECT (session), "caller-session-id");
 
@@ -1199,18 +1199,7 @@ manager_interface_init (GdmDBusManagerIface *interface
 static gboolean
 display_is_on_seat0 (GdmDisplay *display)
 {
-        gboolean is_on_seat0 = TRUE;
-        char *seat_id = NULL;
-
-        g_object_get (G_OBJECT (display), "seat-id", &seat_id, NULL);
-
-        if (g_strcmp0 (seat_id, "seat0") != 0) {
-            is_on_seat0 = FALSE;
-        }
-
-        g_free (seat_id);
-
-        return is_on_seat0;
+        return TRUE;
 }
 
 static gboolean
@@ -2018,12 +2007,44 @@ on_user_session_died (GdmSession *session,
         remove_user_session (manager, session);
 }
 
-static char *
+char *
 get_display_device (GdmManager *manager,
                     GdmDisplay *display)
 {
-        /* systemd finds the display device out on its own based on the display */
-        return NULL;
+        char    *out;
+        char    *command;
+        char    *display_name = NULL;
+        int      status;
+        gboolean res;
+        GError  *error;
+
+        g_object_get (G_OBJECT (display),
+                      "x11-display-name", &display_name,
+                      NULL);
+
+        error = NULL;
+        command = g_strdup_printf (CONSOLEKIT_DIR "/ck-get-x11-display-device --display %s",
+                                   display_name);
+        g_free (display_name);
+
+        g_debug ("GdmManager: Running helper %s", command);
+        out = NULL;
+        res = g_spawn_command_line_sync (command,
+                                         &out,
+                                         NULL,
+                                         &status,
+                                         &error);
+        if (! res) {
+                g_warning ("GdmManager: Could not run helper %s: %s", command, error->message);
+                g_error_free (error);
+        } else {
+                out = g_strstrip (out);
+                g_debug ("GdmManager: Got tty: '%s'", out);
+        }
+
+        g_free (command);
+
+        return out;
 }
 
 static void
@@ -2033,6 +2054,7 @@ on_session_reauthenticated (GdmSession *session,
 {
         gboolean fail_if_already_switched = FALSE;
 
+#if 0
         if (gdm_session_get_display_mode (session) == GDM_SESSION_DISPLAY_MODE_REUSE_VT) {
                 const char *seat_id;
                 char *session_id;
@@ -2051,6 +2073,7 @@ on_session_reauthenticated (GdmSession *session,
                         g_free (session_id);
                 }
         }
+#endif
 
         /* There should already be a session running, so jump to its
          * VT. In the event we're already on the right VT, (i.e. user
